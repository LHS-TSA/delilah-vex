#pragma config(Sensor, dgtl2,  ledRed,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  ledGreen,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  sonarFront,    sensorSONAR_inch)
#pragma config(Sensor, dgtl6,  armSwitch,     sensorTouch)
#pragma config(Sensor, dgtl12, autonJumper,   sensorTouch)
#pragma config(Sensor, I2C_1,  leftEncoder,   sensorNone)
#pragma config(Sensor, I2C_2,  rightEncoder,  sensorNone)
#pragma config(Motor,  port4,  motorFL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,  motorFR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,  motorBL,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,  motorBR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,  armRight,      tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,  armLeft,       tmotorVex393_MC29, openLoop)
// Code automatically generated by 'ROBOTC' configuration wizard

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code
#include "Vex_Competition_Includes.c"
#include "../include/constants.h"

// Global Variables
short facing = 0;               // Sets which side is front (0-7)
bool slowMode = false;          // Reduces speed by indicated percent

// Include functions
#include "status.c"
#include "movement.c"
#include "autonomous.c"
#include "control.c"
// #include "logger.c"

/**
 * Pre-Autonomous Functions.
 * Includes all activities that occur before the competition starts; Turns the
 * leds off and sets up the slave motors.
 */
void pre_auton() {
  bStopTasksBetweenModes = true;

  // Set LEDs to correct values
  stat_flashLeds(6);
}

/**
 * Autonomous Task.
 */
task autonomous() {
  int distSideMvt = 10;
  int autonSpeed = (SensorValue[autonJumper] ? -65 : 65);

  atn_mvtFwdSnr(40, 127, false);
  // wait1Msec(250);
  // 9mvtAutonSide(distSideMvt * 1.2, autonSpeed);
  for (int i=0; i<3; i++) {
    wait1Msec(250);
    atn_mvtStar();
    atn_mvtSide(distSideMvt * 2, -autonSpeed);
  }

  /*
  for (int i=0; i<10; i++) {
    mvtAutonStar();
    mvtAutonSide(distSideMvt, autonSpeed);
  }
  */
}

/**
 * User Control Task.
 */
task usercontrol() {
  while (true) {
    // logState();
    ctl_testFlipSides();
    ctl_testSlowMode();
    ctl_testHighHangMode();
    ctl_testJoysticks();
    ctl_testSideMovement();
    ctl_testHighHang();
  }
}
