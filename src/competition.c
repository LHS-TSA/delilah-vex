#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  autonJumper,  sensorTouch)
#pragma config(Sensor, dgtl2,  ledRed,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  ledGreen,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  sonarFront,   sensorSONAR_inch)
#pragma config(Sensor, dgtl6,  armSwitch,    sensorTouch)
#pragma config(Sensor, I2C_1,  leftEncoder,  sensorQuadEncoderOnI2CPort,   , AutoAssign)
#pragma config(Sensor, I2C_2,  rightEncoder, sensorQuadEncoderOnI2CPort,   , AutoAssign)
#pragma config(Motor,  port1,  rightMaster,  tmotorVex393_HBridge, openLoop, reversed, driveRight)
#pragma config(Motor,  port2,  rightSlave1,  tmotorVex393_MC29,    openLoop, driveRight)
#pragma config(Motor,  port3,  rightSlave2,  tmotorVex393_MC29,    openLoop, driveRight)
#pragma config(Motor,  port4,  leftSlave1,   tmotorVex393_MC29,    openLoop, driveLeft)
#pragma config(Motor,  port5,  leftSlave2,   tmotorVex393_MC29,    openLoop, driveLeft)
#pragma config(Motor,  port6,  leftMaster,   tmotorVex393_MC29,    openLoop, driveLeft)
#pragma config(Motor,  port7,  sideMotor,    tmotorVex393_MC29,    openLoop)
#pragma config(Motor,  port8,  armRight,     tmotorVex393_MC29,    openLoop, driveLeft)
#pragma config(Motor,  port9,  armLeft,      tmotorVex393_MC29,    openLoop)
// Code automatically generated by 'ROBOTC' configuration wizard

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// Global Variables
bool isFlipped = false;         // Toggles which side is front
bool slowMode = false;          // Reduces speed by indicated percent
bool modeHighHang = false;			// Disables the motor protection on high hang
int slowModePercent = 4;        // Percent to reduce forward motion (Default 4)
int slowModePercentSide = 3;    // Percent to reduce sideways motion (Default 3)
int jsThreshold = 25; 					// Minimum amount for joystick register movement
int shaftFullCycle = 392;       // Shaft encoder value at one revolution
int shaftOneInch = 31;          // Shaft encoder value at one inch
int timeOneInch = 58;           // Miliseconds to spin for one inch
int MotorCorrection = 111;			// Percent to decrease left motors
unsigned int loopCount = 0;     // Debug output counter

// SECTION: Movement Functions

/**
 * Left motors movement control.
 * Sets the value of the left motors in normal mode or right motors in flipped
 * mode; Speed is divided by slowModePercent if in slow mode
 *
 * @param speed Speed in range -127 to 127
 */
void mvtForwardLeft(signed char speed) {
  if (slowMode) { speed = speed / slowModePercent; }

  if (!isFlipped) {
    motor[leftMaster] = (-speed * MotorCorrection) / 127;
  } else {
    motor[rightMaster] = -speed;
  }
}

/**
 * Right motors movement control.
 * Sets the value of the right motors in normal mode or left motors in flipped
 * mode; Speed is divided by slowModePercent if in slow mode
 *
 * @param speed Speed in range -127 to 127
 */
void mvtForwardRight(signed char speed) {
  if (slowMode) { speed = speed / slowModePercent; }

  if (!isFlipped) {
    motor[rightMaster] = speed;
  } else {
    motor[leftMaster] = (speed * MotorCorrection) / 127;
  }
}

/**
 * Left motors movement control.
 * Sets the value of the side motors in normal mode; Value is negated in flipped
 * mode; Speed is divided by slowModePercentSide if in slow mode
 *
 * @param speed Speed in range -127 to 127
 */
void mvtSide(signed char speed) {
  if (isFlipped) { speed = -speed; }
  if (slowMode) { speed = speed / slowModePercentSide; }

  motor[sideMotor] = speed;
}

/**
 * High hang motors movement control.
 * Sets the value of the high hang motors in normal mode; Value is not effected
 * by flipped mode or slow mode
 *
 * @param speed Speed in range -127 to 127
 */
void mvtHighHang(signed char speed) {
  if (speed < 0 && (SensorValue(armSwitch) && !modeHighHang)) {
    motor[armLeft] = 0;
    motor[armRight] = 0;
  } else {
    motor[armLeft] = speed;
    motor[armRight] = -speed;
  }
}

// SECTION: Autonomous Movement

/**
 * Autonomous forward encoder movement control.
 * Controls the motion of the motors using the motor encoders during an
 * autonomous period
 *
 * @param dist Distance to move forward in inches
 * @param speed Speed in range -127 to 127
 */
void mvtAutonFwdEnc(int dist, signed char speed) {
  if (speed == 0) { return; }

  SensorValue[leftEncoder] = 0;
  SensorValue[rightEncoder] = 0;

  dist *= shaftOneInch;

  while (SensorValue[leftEncoder] < dist && SensorValue[rightEncoder] < dist) {
    mvtForwardLeft(speed);
    mvtForwardRight(speed);
  }

  mvtForwardLeft(0);
  mvtForwardRight(0);
}

/**
 * Autonomous forward sonar movement control.
 * Controls the motion of the motors using the sonar thing I can't spell during an
 * autonomous period
 *
 * @param dist Distance to move forward in inches
 * @param speed Speed in range -127 to 127
 * @param relative add to current position
 */
void mvtAutonFwdSnr(int dist, signed char speed, bool relative) {
  if (speed == 0) { return; }

  if (SensorValue[sonarFront] == -1) {    // If sensor is messed up
    for (int i=0; i<4; i++) {
      SensorValue[ledGreen] = 1;
      SensorValue[ledRed] = 1;
      wait1Msec(25);
      SensorValue[ledGreen] = 0;
      SensorValue[ledRed] = 0;
      wait1Msec(25);
    }
    SensorValue[ledGreen] = (slowMode ? 1 : 0);
    SensorValue[ledRed] = (isFlipped ? 0 : 1);

    mvtAutonFwdEnc(dist, speed);
    return;
  }

  if (relative) {
    dist += SensorValue[sonarFront];
  }

  while (SensorValue[sonarFront] < dist) {
    mvtForwardLeft(speed);
    mvtForwardRight(speed);
  }

  mvtForwardLeft(0);
  mvtForwardRight(0);
}

/**
 * Autonomous sideways movement control.
 * Controls the motion of the sideways motors during an autonomous period;
 * dist is in inches, speed is in range -+ 127
 *
 * @param dist Distance to move forward in inches
 * @param speed Speed in range -127 to 127
 */
void mvtAutonSide(int dist, signed char speed) {
  dist *= timeOneInch;

  mvtSide(speed);
  wait1Msec(dist);
  mvtSide(0);

  if (speed > 0) {
   mvtForwardRight(127);
   wait1Msec(50);               // Sideways correction timing
   mvtForwardRight(0);
  } else {
   mvtForwardLeft(127);
   wait1Msec(50);               // Sideways correction timing
   mvtForwardLeft(0);
  }
}

 /**
  * Autonomous star knocking movement control.
  * Controls the high hang bar during the autonomous period; Extends arm, moves
  * back, retracts arm, and returns to initial position
  */
void mvtAutonStar() {
  // Extend Arm
  mvtHighHang(127);
  wait1Msec(500);               // High hang upwards duration
  mvtHighHang(0);

  // Move back so doesn't climb fence
  mvtForwardLeft(-127);
  mvtForwardRight(-127);
  wait1Msec(200);               // High hang shift duration
  mvtForwardLeft(0);
  mvtForwardRight(0);

  // Lower arm
  while (SensorValue[armSwitch]) {
    mvtHighHang(-127);
  }
  mvtHighHang(0);

  // Return to position
  mvtForwardLeft(127);
  mvtForwardRight(127);
  wait1Msec(200);               // High hang return shift duration
  mvtForwardLeft(0);
  mvtForwardRight(0);
}

// SECTION: Controller Functions

/**
 * Controls when front side of robot is swapped.
 * Tests for presses to Btn8D and flips the bool value isFlipped when activated;
 * The red led will be active when in flipped mode
 */
void ctlFlipSides() {
  if (vexRT[Btn8D]) {
    wait1Msec(250);       // This is to keep button press from rapidly switching
    isFlipped = !isFlipped;
    SensorValue[ledRed] = (isFlipped ? 0 : 1);
  }
}

/**
 * Controls when motors are at reduced speed.
 * Tests for presses to Btn8R and flips the bool value slowMode when activated;
 * The green led will be active when in slow mode
 */
void ctlSlowMode() {
  if (vexRT[Btn8R]) {
    wait1Msec(250);
    slowMode = !slowMode;
    SensorValue[ledGreen] = (slowMode ? 1 : 0);
  }
}

/**
 * Controls when the high hang protection is disabled.
 * Tests for presses to Btn8L and flips the bool value modeHighHang when activated;
 * The green led will blink if enabled and the red led will blink when disabled
 */
void ctlHighHangMode() {
  if (vexRT[Btn8L]) {
    modeHighHang = !modeHighHang;

    if (modeHighHang) {
      SensorValue[ledGreen] = 1;
      wait1Msec(62);
      SensorValue[ledGreen] = 0;
      wait1Msec(62);
      SensorValue[ledGreen] = 1;
      wait1Msec(62);
      SensorValue[ledGreen] = 0;
      wait1Msec(62);
      SensorValue[ledGreen] = (slowMode ? 1 : 0);
    } else {
      SensorValue[ledRed] = 1;
      wait1Msec(62);
      SensorValue[ledRed] = 0;
      wait1Msec(62);
      SensorValue[ledRed] = 1;
      wait1Msec(62);
      SensorValue[ledRed] = 0;
      wait1Msec(62);
      SensorValue[ledRed] = (isFlipped ? 0 : 1);
    }
  }
}

/**
 * Controls the speed of the left and right motors.
 * Tests Ch3 for right motors and Ch2 for left motors; Does not activate movement
 * without joystick being over jsThreshold to prevent ghost movement
 */
void ctlJoysticks() {
  if (vexRT[Ch3] <= -jsThreshold || vexRT[Ch3] >= jsThreshold) {
    mvtForwardRight(vexRT[Ch3]);
  } else {
    mvtForwardRight(0);
  }

  if (vexRT[Ch2] <= -jsThreshold || vexRT[Ch2] >= jsThreshold) {
    mvtForwardLeft(vexRT[Ch2]);
  } else {
    mvtForwardLeft(0);
  }
}

/**
 * Controls the speed of the side motor.
 * Tests Btn6D and Bth5D for activation and sets speed to highest level for the
 * duration of their activation
 */
void ctlSideMovement() {
  if (vexRT[Btn6D]) {
    mvtSide(127);
  } else if (vexRT[Btn5D]) {
    mvtSide(-127);
  } else {
    mvtSide(0);
  }
}

/**
 * Controls the speed of the high hang motors.
 * Tests Btn7U and Btn7D for activation and sets speed to highest level for the
 * duration of their activation
 */
void ctlHighHang() {
  if (vexRT[Btn7U]) {
    mvtHighHang(127);
  } else if (vexRT[Btn7D]) {
    mvtHighHang(-127);
  } else {
    mvtHighHang(0);
  }
}

/**
 * Logs the state of the motors.
 * Writes to the Debug Stream in a comma-seperated formatted list
 */
void logState() {
  if (loopCount == 0) {   // Prints the dubug header on first output
    writeDebugStreamLine("loopCount,leftMotor,rightMotor,sideMotor,highHang,slowMode,isFlipped");
  }

  writeDebugStream("%i", loopCount);
  writeDebugStream(",%i",motor[leftMaster]);
  writeDebugStream(",%i", motor[rightMaster]);
  writeDebugStream(",%i",motor[sideMotor]);
  writeDebugStream(",%i",motor[armLeft]);
  writeDebugStream(",%d",slowMode);
  writeDebugStreamLine(",%d",isFlipped);

  loopCount++;
}

/**
 * Pre-Autonomous Functions.
 * Includes all activities that occur before the competition starts; Turns the
 * leds off and sets up the slave motors.
 */
void pre_auton() {
  bStopTasksBetweenModes = true;

  // Slave Motors
  slaveMotor(leftSlave2, leftMaster);
  slaveMotor(leftSlave1, leftMaster);

  slaveMotor(rightSlave2, rightMaster);
  slaveMotor(rightSlave1, rightMaster);

  // Turn off LEDs
  SensorValue[ledGreen] = (slowMode ? 1 : 0);
  SensorValue[ledRed] = (isFlipped ? 0 : 1);
}

/**
 * Autonomous Task.
 */
task autonomous() {
  int distSideMvt = 12;
  int autonSpeed = (SensorValue[autonJumper] ? -127 : 127);

  mvtAutonFwdSnr(55, 127, false);
  mvtAutonSide(distSideMvt * 1.5, autonSpeed);
  mvtAutonSide(distSideMvt * 1.5, autonSpeed);
  for (int i=0; i<4; i++) {
    mvtAutonStar();
    mvtAutonSide(distSideMvt * 1.5, autonSpeed);
  }
  for (int i=0; i<10; i++) {
    mvtAutonStar();
    mvtAutonSide(distSideMvt * 1.5, autonSpeed);
  }
}

/**
 * User Control Task.
 */
task usercontrol() {
  while (true) {
    // logState();
    ctlFlipSides();
    ctlSlowMode();
    ctlHighHangMode();
    ctlJoysticks();
    ctlSideMovement();
    ctlHighHang();
  }
}
